# The 'utl' (Util) jsonnet library contains utility functions that are used by most
# libraries here, and/or don't fit in any other specialized library.


local makeObjectDrop5(keys,values,offset) =
	local v0 = values[offset];
	local v1 = values[offset+1];
	local v2 = values[offset+2];
	local v3 = values[offset+3];
	local v4 = values[offset+4];
	{ [if v0 != null then keys[offset]]: v0, [if v1 != null then keys[offset+1]]: v1,
	  [if v2 != null then keys[offset+2]]: v2, [if v3 != null then keys[offset+3]]: v3,
	  [if v4 != null then keys[offset+4]]: v4, };

local makeObjectDropX(keys,values,offset) =
	local size = std.length(keys) - offset;
	if size == 0 then
		{}
	else
		local v0 = values[offset];
		if size == 1 then
			{ [if v0 != null then keys[offset]]: v0, }
		else
			local v1 = values[offset+1];
			if size == 2 then
				{ [if v0 != null then keys[offset]]: v0, [if v1 != null then keys[offset+1]]: v1, }
			else
				local v2 = values[offset+2];
				if size == 3 then
					{ [if v0 != null then keys[offset]]: v0, [if v1 != null then keys[offset+1]]: v1,
					  [if v2 != null then keys[offset+2]]: v2, }
				else
					if size == 4 then
						local v3 = values[offset+3];
						{ [if v0 != null then keys[offset]]: v0, [if v1 != null then keys[offset+1]]: v1,
						  [if v2 != null then keys[offset+2]]: v2, [if v3 != null then keys[offset+3]]: v3, }
					else if size == 5 then
						makeObjectDrop5(keys,values,offset)
					else
						makeObjectDrop5(keys,values,offset) + makeObjectDropX(keys,values,offset+5);

local makeObjectKeep5(keys,values,offset) =
	{ [keys[offset]]: values[offset], [keys[offset+1]]: values[offset+1], [keys[offset+2]]: values[offset+2],
	  [keys[offset+3]]: values[offset+3], [keys[offset+4]]: values[offset+4], };

local makeObjectKeepX(keys,values,offset) =
	local size = std.length(keys) - offset;
	if size == 0 then
		{}
	else if size == 1 then
		{ [keys[offset]]: values[offset] }
	else if size == 2 then
		{ [keys[offset]]: values[offset], [keys[offset+1]]: values[offset+1], }
	else if size == 3 then
		{ [keys[offset]]: values[offset], [keys[offset+1]]: values[offset+1],
		  [keys[offset+2]]: values[offset+2], }
	else if size == 4 then
		{ [keys[offset]]: values[offset], [keys[offset+1]]: values[offset+1],
		  [keys[offset+2]]: values[offset+2], [keys[offset+3]]: values[offset+3], }
	else if size == 5 then
		makeObjectKeep5(keys,values,offset)
	else
		makeObjectKeep5(keys,values,offset) + makeObjectKeepX(keys,values,offset+5);

{
	local utl = self,
	
	# Library description
	DESCIPTION:: "The 'utl' (Util) jsonnet library contains utility functions that are used by most "
		+"libraries here,\nand/or don't fit in any other specialized library.",
	
	# All the imported libraries
	IMPORTS:: {},
	
	# Returns true for an "empty" value (null | '' | {} | []). Does NOT return true for 'false' / '0'
	empty(value)::
		(value == null || value == '' || value == {} || value == []),
	
	# Returns true for an "false" value (null | '' | {} | [] | false | 0)
	no(value)::
		(value == null || value == '' || value == {} || value == [] || value == false || value == 0),
	
	# Returns true for an "true" value: NOT (null | '' | {} | [] | false | 0)
	yes(value)::
		!utl.no(value),

	# "Applies" the parameters to the function, calling it and returning the result.
	# Will FAIL if "func" is not a function, "params" is not an array, or std.length(params) > 9.
	apply(func,params)::
		assert std.type(func) == "function": "'func' must be a function, but is "+std.type(func);
		assert std.type(params) == "array": "'params' must be an array of parameters (can be empty), but is "
			+std.type(params);
		local p = params;
		local n = std.length(p);
		if n == 0 then
			func()
		else if n == 1 then
			func(p[0])
		else if n == 2 then
			func(p[0],p[1])
		else if n == 3 then
			func(p[0],p[1],p[2])
		else if n == 4 then
			func(p[0],p[1],p[2],p[3])
		else if n == 5 then
			func(p[0],p[1],p[2],p[3],p[4])
		else if n == 6 then
			func(p[0],p[1],p[2],p[3],p[4],p[5])
		else if n == 7 then
			func(p[0],p[1],p[2],p[3],p[4],p[5],p[6])
		else if n == 8 then
			func(p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7])
		else if n == 9 then
			func(p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7],p[8])
		else
			error "Too many parameters: "+std.toString(n),

	# Returns true if the function "func" return true for any element in the array "arr"
	matchAny(func,arr)::
		(std.length(std.filter(func, arr)) > 0),

	# Converts an object to an array. The field names must be unsigned integers.
	# Missing fields will be set to "default", which defaults to null.
	object2Array(obj,default=null)::
		if obj == null then
			null
		else
			assert std.type(obj) == 'object';
			local fields = std.objectFields(obj);
			if std.length(fields) == 0 then
				[]
			else
				local idx = std.map(std.parseInt, fields);
				local max = std.foldl(std.max, idx, -1);
				local get(i) = std.get(obj,std.toString(i),default);
				std.makeArray(max+1, get),

	# Takes two arrays, keys and values, which must have the same length, and use them to build an object.
	# Keys must be strings.
	makeObject(keys,values,keepNullValues=true)::
		assert std.type(keys) == 'array';
		assert std.type(values) == 'array';
		assert std.type(keepNullValues) == 'boolean';
		local nKeys = std.length(keys);
		local nValues = std.length(values);
		assert nKeys == nValues;
		if keepNullValues then
			makeObjectKeepX(keys,values,0)
		else
			makeObjectDropX(keys,values,0),
	
	# Add all elements of arr
	sum(arr, init)::
		std.foldr(function(a,b) a + b, arr, init),

	# All functions in the library, with their parameter names
	FUNCS:: {
		empty: ['value'],
		no: ['value'],
		yes: ['value'],
		apply: ['func', 'params'],
		matchAny: ['func', 'arr'],
		sum: ['arr', 'init'],
		object2Array: ['obj', 'default?'],
		makeObject: ['keys', 'values','keepNullValues?'],
	},
}
