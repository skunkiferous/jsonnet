# jsonnet library "int" helps (a bit) dealing with integers, that are outside the range that can correctly
# be represented as a "number" (64bit double). For completness, it also included a isNumberStr(),
# safeParseNumber(), isBooleanStr() und safeParseBoolean() functions.

local log = import 'log.libjsonnet';
local utl = import 'utl.libjsonnet';

# field name separator (i.e. "a.b")
local SEP = ".";

# Valid number characters
local INT_CHARS = "0123456789";
local HEX_CHARS = "0123456789abcdefABCDEF";

# Character CODE of 0
local ZERO = std.codepoint('0');

# Compares two integers that have the same, non-zero sign, and are strings.
local cmpStr(a,b,negative) =
	if a == b then
		0
	else
		local aLen = std.length(a);
		local bLen = std.length(b);
		local a2 = if negative then std.substr(a, 1, aLen-1)  else a;
		local b2 = if negative then std.substr(b, 1, bLen-1) else b;
		local aLen2 = if negative then aLen-1  else aLen;
		local bLen2 = if negative then bLen-1 else bLen;
		local maxLen = std.max(aLen2, bLen2);
		local a3 = utl.extendStr(a2,maxLen,'0',true);
		local b3 = utl.extendStr(b2,maxLen,'0',true);
		local unsignedCmp = if a3 < b3 then -1 else 1;
		# Inverse result if negative is true!
		if negative then -unsignedCmp else unsignedCmp;

# Compares two integers that have the same, non-zero sign.
local cmpSameSign(a,b,negative) =
	local aType = std.type(a);
	local bType = std.type(b);
	if aType == bType then
		if aType == 'number' then
			if a == b then 0 else if a < b then -1 else 1
		else
			cmpStr(a,b,negative)
	else
		local aStr = if aType == 'string' then a else std.toString(a);
		local bStr = if bType == 'string' then b else std.toString(b);
		cmpStr(aStr,bStr,negative);

# Skips unneeded zeros (cause error in std.parseJson(num)! )
local skipZerosOfNumberStr(str) =
	local cleaned = if std.startsWith(str, '-') then
		(if std.startsWith(str, '-0') then
			'-'+std.lstripChars(std.substr(str, 1, std.length(str)-1), '0')
		else str)
	else
		std.lstripChars(str, '0');
	if (cleaned == '-' || cleaned == '') then
		'0'
	else if std.startsWith(cleaned, '-.') then
		'-0'+std.substr(cleaned, 1, std.length(cleaned)-1)
	else if std.startsWith(cleaned, '.') then
		'0'+cleaned
	else
		cleaned;

# Parse a string into a number, stripping unneeded zeros (cause error in std.parseJson(num)! )
local pasreNumber(str) =
	local maybeNum = std.parseJson(skipZerosOfNumberStr(str));
	assert std.type(maybeNum) == 'number';
	maybeNum;

# Takes two unsigned integers as strings, and adds b to a.
local addUIntStr(a,b) =
    # Find length of both input and maximum
    local al = std.length(a);
    local bl = std.length(b);
    local ml = std.max(al, bl);
    # Pad both input to maximum
    local pa = std.repeat('0', ml-al)+a;
    local pb = std.repeat('0', ml-bl)+b;
    # Break into character arrays
    local ach = std.encodeUTF8(pa);
    local bch = std.encodeUTF8(pb);
    # We iterate backward over all indexes
    local loop = std.reverse(std.range(0,ml-1));
    # Add one pair of digits, and combine with carry and result do far.
    local addOne(carry_result,idx) =
        local carry = carry_result[0];
        local lastResult = carry_result[1];
        # Compute "numerical" digit of a
        local ad = ach[idx] - ZERO;
        # Compute "numerical" digit of b
        local bd = bch[idx] - ZERO;
        # Add
        local r = ad + bd + carry;
        # Compute carry and new result
        if r >= 10 then
            [1,[(r%10) + ZERO]+lastResult]
        else
            [0,[r + ZERO]+lastResult];
    # Join all digits
    skipZerosOfNumberStr(std.decodeUTF8(std.foldl(addOne, loop, [0,[]])[1]));

# Takes two unsigned integers as strings, and substract smaller from greater.
local subUIntStr(greater,smaller) =
	local a = greater;
	local b = smaller;
    # Find length of both input and maximum
    local al = std.length(a);
    local bl = std.length(b);
    local ml = std.max(al, bl);
    # Pad both input to maximum
    local pa = std.repeat('0', ml-al)+a;
    local pb = std.repeat('0', ml-bl)+b;
    # Break into character arrays
    local ach = std.encodeUTF8(pa);
    local bch = std.encodeUTF8(pb);
    # We iterate over all indexes
    local loop = std.range(1,ml);
    # Add one pair of digits, and combine with carry and result do far.
    local subOne(carry_result,idx) =
        local carry = carry_result[0];
        local lastResult = carry_result[1];
		local idx2 = ml - idx;
        # Compute "numreical" digit of a
        local ad = ach[idx2] - ZERO;
        # Compute "numerical" digit of b
        local bd = bch[idx2] - ZERO;
        # Sub
        local r = ad - bd - carry;
        # Compute carry and new result
        if r < 0 then
            [1,[r + 10 + ZERO]+lastResult]
        else
            [0,[r + ZERO]+lastResult];
    # Join all digits
    skipZerosOfNumberStr(std.decodeUTF8(std.foldl(subOne, loop, [0,[]])[1]));

# Compute "numerical" digits
local ch2d(ch) =
	ch - ZERO;

# Compute "charcter" digits
local d2ch(d) =
	d + ZERO;

# Takes two unsigned integers as strings, and multiplies a by b.
local multUIntStr(a,b) =
    # Find length of both input and maximum
    local al = std.length(a);
    local bl = std.length(b);
    local ml = std.max(al, bl);
    # Pad both input to maximum
    # Break into character arrays
    # Compute "numerical" digits
    local ad = std.map(ch2d, std.reverse(std.encodeUTF8(a)));
    local bd = std.map(ch2d, std.reverse(std.encodeUTF8(b)));
	# Starter value for "carry" array
	local resLen = al+bl;
	local cZero = std.repeat([0], resLen);
	# Indexes for inner loop
	local innerIdx = std.range(0,al-1);
	# Inner loop
	local innerLoop(cd,i) =
		# Content of inner loop
		local inner(tmp,j) =
			local carry = tmp[0];
			local newC = tmp[1];
			local t =  (ad[j] * bd[i]) + cd[i+j] + carry;
			local newCarry = std.floor(t/10);
			local newcIJ = t % 10;
			[newCarry, [newcIJ]+newC];
		local newCPart = std.foldl(inner, innerIdx, [0,[]])[1];
		local cBefore = if i > 0 then cd[0:(i-1)] else [];
		local cAfter = if i < ml-1 then cd[(i+ml):resLen] else [];
		cAfter + newCPart + cBefore;
	local digits = std.foldl(innerLoop, std.range(0,bl-1), cZero);
	# Compute "charcter" digits
	local digitsCh = std.map(d2ch, digits);
    # Join all digits
    skipZerosOfNumberStr(std.decodeUTF8(digitsCh));

{
	local int = self,
	
	# Library description
	DESCIPTION:: "jsonnet library 'int' helps (a bit) dealing with integers, that are outside the range"
		+" that can correctly be represented\nas a 'number' (64bit double). For completness, it also "
		+"included a isNumberStr(), safeParseNumber(), isBooleanStr() und safeParseBoolean() functions.",
	
	# All the imported libraries
	IMPORTS:: { log: log, utl: utl },

	# Integer limit in JSON number
	MIN_SAFE_INTEGER:: -9007199254740991,
	MAX_SAFE_INTEGER:: 9007199254740991,

	# Integer limits. They are ouside of "safe" limits, so must be strings.
	MIN_SIGNED_INT64::   "-9223372036854775808",
	MAX_SIGNED_INT64::    "9223372036854775807",
	MAX_UNSIGNED_INT64:: "18446744073709551615",

	# If num is a string, converts it to a number, at the risk of loosing precising.
	# WARNING: This function assume the str is a valid number. It will FAIL if not.
	# Use safeParseNumber() or safeParseInteger() to parse raw user input.
	toNumber(num)::
		if std.type(num) == 'number' then
			num
		else
			pasreNumber(num),

	# Returns true, if "str" is a boolean
	isBooleanStr(str)::
		(str == "true" || str == "false"),

	# Returns true, if "str" is an unsigned integer (even huge integers, that cannot be represented correctly
	# as a JSON number).
	isUIntegerStr(str)::
		(std.type(str) == "string") && (std.length(str) > 0) &&
			(std.length(std.stripChars(str, INT_CHARS)) == 0),

	# Returns true, if "str" is an integer (even huge integers, that cannot be represented correctly as a
	# JSON number).
	isIntegerStr(str)::
		if std.type(str) == "string" then
			if std.startsWith(str,'-') then
				int.isUIntegerStr(std.substr(str, 1, std.length(str)-1))
			else
				int.isUIntegerStr(str)
		else
			false,

	# Returns true, if "str" is a number
	isNumberStr(str)::
		if std.type(str) != "string" then
			false
		else
			local len = std.length(str);
			if len == 0 then
				false
			else
				local dots = std.findSubstr(SEP, str);
				local nDots = std.length(dots);
				if nDots == 0 then
					int.isIntegerStr(str)
				else if nDots == 1 then
					local lp = dots[0];
					local prefix = std.substr(str, 0, lp);
					# "+1" to skip separator too
					local rest = std.substr(str, lp+1, len-lp);
					int.isIntegerStr(prefix) && int.isUIntegerStr(rest)
				else
					false,

	# *Safely* parse a boolean value. Returns an object like { result: VALUE, errors: [] }
	# "result" is null and errors contains error message(s) if str is not a valid value.
	safeParseBoolean(source, index, field, str)::
		if int.isBooleanStr(str) then
			{ result: (str == "true"), errors: [] }
		else
			{ result: null, errors: [  log.badVal(source, index, field, 'boolean', str) ] },

	# Returns true, if "str" is an hexadecimal integer
	isHexStr(str)::
		if std.type(str) == "string" then
			local len = std.length(str);
			(len > 2) && (std.startsWith(str, "0x") || std.startsWith(str, "0X")) &&
				(std.length(std.stripChars(std.substr(str, 2, len-2), HEX_CHARS)) == 0)
		else
			false,

	# Returns true, if this integer is within the range that can be correctly represented as a JSON number
	isNotHugeInt(num)::
		(std.type(num) == "number") && int.isIntegerStr(std.toString(num)) &&
			(num >= int.MIN_SAFE_INTEGER) && (num <= int.MAX_SAFE_INTEGER),

	# Convert an integer back to a number if possible
	local intToNumberSafe(num) =
		if std.type(num) == 'number' then
			num
		else
			local cleaned = skipZerosOfNumberStr(num);
			local num2 = std.parseJson(cleaned);
			assert std.type(num2) == 'number';
			if (num2 >= int.MIN_SAFE_INTEGER) && (num2 <= int.MAX_SAFE_INTEGER) then num2 else cleaned,

	# *Safely* parse a integer value. Returns an object like { result: VALUE, errors: [] }
	# "result" is null and errors contains error message(s) if str is not a valid value.
	# "str" is potentially too "big" to be correctly represented with a "number".
	# In this case, it will remain a string, and a warning will be given in "errors".
	safeParseInteger(source, index, field, str)::
		if int.isIntegerStr(str) then
			# pasreNumber(str) will return a simple number value, if str is really a number
			local num = pasreNumber(str);
			if int.isNotHugeInt(num) then
				{ result: num, errors: [] }
			else
				local cleaned = if std.startsWith(str, '-')	then
					(if std.startsWith(str, '-0') then
						'-'+std.lstripChars(std.substr(str, 1, std.length(str)-1), '0')
					else str)
				else
					std.lstripChars(str, '0');
				{ result: cleaned, errors: [ log.warnVal(source, index, field, 'integer', str,
					'cannot be safely represented as a number.') ] }
		else
			{ result: null, errors: [ log.badVal(source, index, field, 'integer', str) ] },

	# *Safely* parse a HEX integer value. Returns an object like { result: VALUE, errors: [] }
	# "result" is null and errors contains error message(s) if str is not a valid value.
	# "str" is potentially too "big" to be correctly represented with a "number".
	# In this case, it will remain a string, and a warning will be given in "errors".
	safeParseHex(source, index, field, str)::
		if int.isHexStr(str) then
			local num = std.parseHex(std.substr(str, 2, std.length(str)-2));
			# hex num will never be < 0!
			if num <= int.MAX_SAFE_INTEGER then
				{ result: num, errors: [] }
			else
				# TODO: ideally, we would still convert that hex string into a decimal str
				{ result: str, errors: [ log.warnVal(source, index, field, 'hex', str,
					'cannot be safely represented as a number.') ] }
		else
			{ result: null, errors: [ log.badVal(source, index, field, 'hex', str) ] },

	# *Safely* parse a decimal number value (i.e. '123.456'). Returns an object like { result: VALUE,
	# errors: [] }. "result" is null and errors contains error message(s) if str is not a valid value.
	safeParseNumber(source, index, field, str)::
		if int.isNumberStr(str) then
			# pasreNumber(str) will return a simple number value, if str is really a number
			{ result: pasreNumber(str), errors: [] }
		else
			{ result: null, errors: [ log.badVal(source, index, field, 'number', str) ] },
	
	# Returns -1, 0 or 1 based on the sign of the integer.
	sign(num)::
		# Assume num is an integer as string, if not a number ...
		std.sign(int.toNumber(num)),
	
	# Returns an array with the sign and the unsigned number.
	splitSign(num)::
		# Assume num is an integer as string, if not a number ...
		local isNum = std.type(num) == "number";
		local num2 = if isNum then num else pasreNumber(num);
		local sign = std.sign(num2);
		if sign >= 0 then
			if isNum then [sign, num] else [sign, skipZerosOfNumberStr(num)]
		else if isNum then
			[sign, -num]
		else
			local cleaned = skipZerosOfNumberStr(num);
			[sign, std.substr(cleaned, 1, std.length(cleaned)-1)],

	# Compares the integers a and b. Returns 0 if equals, 1 is a > b else -1
	cmp(a,b)::
		local aSign = int.sign(a);
		local bSign = int.sign(b);
		if aSign == 0 then
			if bSign == 0 then
				0
			else if bSign > 0 then
				-1
			else
				1
		else if aSign != bSign then
			if aSign > 0 then 1 else -1
		else
			# a and b have same sign, and are not 0, so we need "real" comparision
			cmpSameSign(a,b,aSign < 0),

	# Compares the integers a and b. Returns true if a < b.
	lt(a,b)::
		int.cmp(a,b) < 0,

	# Compares the integers a and b. Returns true if a <= b.
	le(a,b)::
		int.cmp(a,b) <= 0,

	# Compares the integers a and b. Returns true if a > b.
	gt(a,b)::
		int.cmp(a,b) > 0,

	# Compares the integers a and b. Returns true if a >= b.
	ge(a,b)::
		int.cmp(a,b) >= 0,

	# Compares the integers a and b. Returns true if a == b.
	eq(a,b)::
		int.cmp(a,b) == 0,

	# Compares the integers a and b. Returns true if a != b.
	ne(a,b)::
		int.cmp(a,b) != 0,

	# Compares the integers a and b. Returns the smallest one.
	min(a,b)::
		if int.cmp(a,b) < 0 then a else b,

	# Compares the integers a and b. Returns the biggest one.
	max(a,b)::
		if int.cmp(a,b) > 0 then a else b,

	# Returns true if the number is within the valid (signed) int64 range.
	isInt64(num)::
		int.le(int.MIN_SIGNED_INT64, num) && int.le(num, int.MAX_SIGNED_INT64),

	# Returns true if the number is within the valid unsigned int64 range.
	isUInt64(num)::
		int.le(0, num) && int.le(num, int.MAX_UNSIGNED_INT64),

	# Negates number, even if they are big integers strings.
	neg(num)::
		if std.type(num) == 'number' then
			-num
		else
			local arr = int.splitSign(num);
			local sign = arr[0];
			local uns = arr[1];
			if sign == 0 then
				# 0 stays 0 when negated
				'0'
			else if sign > 0 then
				'-'+uns
			else
				uns,

	# Returns the "absolute" value of a number, even if they are big integers strings.
	abs(num)::
		if std.type(num) == 'number' then
			std.abs(num)
		else
			int.splitSign(num)[1],

	local toNumberStr(num) =
		if std.type(num) == 'string' then
			num
		else
			std.toString(num),

	# Takes two unsigned integers, and adds b to a.
	local doAdd(a,b) =
		local an = int.toNumber(a);
		local bn = int.toNumber(b);
		local ab = an + bn;
		if int.isNotHugeInt(ab) then
			ab
		else
			addUIntStr(toNumberStr(a),toNumberStr(b)),

	# Takes two unsigned integers, and substract b from a.
	local doSub(a,b) =
		local an = int.toNumber(a);
		local bn = int.toNumber(b);
		local ab = an - bn;
		if int.isNotHugeInt(a) && int.isNotHugeInt(b) && int.isNotHugeInt(ab) then
			ab
		else
			local as = toNumberStr(a);
			local bs = toNumberStr(b);
			if int.ge(a, b) then
				subUIntStr(as,bs)
			else
				int.neg(subUIntStr(bs,as)),

	# Takes two integers, and adds b to a.
	local add2(a,b) =
		local aTmp = int.splitSign(a);
		local aSign = aTmp[0];
		local aUns = aTmp[1];
		local bTmp = int.splitSign(b);
		local bSign = bTmp[0];
		local bUns = bTmp[1];
		if aSign == 0 then
			b
		else if bSign == 0 then
			a
		else if aSign == bSign then
			if aSign == 1 then doAdd(a,b) else int.neg(doAdd(aUns,bUns))
		else
			# Signs are different, so it's actually a substraction
			if aSign == 1 then doSub(a,bUns) else doSub(b,aUns),

	# Takes two integers, and adds b to a.
	add(a,b)::
		intToNumberSafe(add2(a,b)),

	# Takes two integers, and substract b from a.
	local sub2(a,b) =
		local aTmp = int.splitSign(a);
		local aSign = aTmp[0];
		local aUns = aTmp[1];
		local bTmp = int.splitSign(b);
		local bSign = bTmp[0];
		local bUns = bTmp[1];
		if aSign == 0 then
			int.neg(b)
		else if bSign == 0 then
			a
		else if aSign == bSign then
			if aSign == 1 then doSub(a,b) else doSub(bUns,aUns)
		else
			# Signs are different, so it's actually an addition
			if aSign == 1 then doAdd(a,bUns) else int.neg(doAdd(aUns,b)),

	# Takes two integers, and substract b from a.
	sub(a,b)::
		intToNumberSafe(sub2(a,b)),

	# Takes two integers, and multiplies a and b.
	local doMult(a,b) =
		local an = int.toNumber(a);
		local bn = int.toNumber(b);
		local ab = an * bn;
		if int.isNotHugeInt(ab) then
			ab
		else if an == 1 then
			b
		else if bn == 1 then
			a
		else
			multUIntStr(toNumberStr(a),toNumberStr(b)),

	# Takes two integers, and multiplies a and b.
	local mult2(a,b) =
		local aTmp = int.splitSign(a);
		local aSign = aTmp[0];
		local aUns = aTmp[1];
		local bTmp = int.splitSign(b);
		local bSign = bTmp[0];
		local bUns = bTmp[1];
		local unsRes = doMult(aUns,bUns);
		if (aSign == 0) || (bSign == 0) then
			0
		else if aSign == bSign then
			# + * + == +, - * - == +
			doMult(aUns,bUns)
		else
			# + * - == - * + == -
			int.neg(doMult(aUns,bUns)),

	# Takes two integers, and multiplies a and b.
	mult(a,b)::
		intToNumberSafe(mult2(a,b)),

	# All functions in the library, with their parameter names
	FUNCS:: {
		isBooleanStr: ['str'],
		isUIntegerStr: ['str'],
		isIntegerStr: ['str'],
		isNumberStr: ['str'],
		safeParseBoolean: ['source', 'index', 'field', 'str'],
		isHexStr: ['str'],
		isNotHugeInt: ['num'],
		safeParseInteger: ['source', 'index', 'field', 'str'],
		safeParseHex: ['source', 'index', 'field', 'str'],
		safeParseNumber: ['source', 'index', 'field', 'str'],
		sign: ['num'],
		cmp: ['a','b'],
		lt: ['a','b'],
		le: ['a','b'],
		gt: ['a','b'],
		ge: ['a','b'],
		eq: ['a','b'],
		ne: ['a','b'],
		min: ['a','b'],
		max: ['a','b'],
		splitSign: ['num'],
		toNumber: ['num'],
		isInt64: ['num'],
		isUInt64: ['num'],
		neg: ['num'],
		abs: ['num'],
		add: ['a','b'],
		sub: ['a','b'],
		mult: ['a','b'],
	},
}