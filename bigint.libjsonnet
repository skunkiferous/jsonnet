# jsonnet library "bigint" helps (a bit) dealing with integers, that are outside the range that can correctly
# be represented as a "number" (64bit double). For completness, it also included a isNumberStr(),
# safeParseNumber(), isBooleanStr() und safeParseBoolean() functions.

local log = import 'log.libjsonnet';
local utl = import 'utl.libjsonnet';

# field name separator (i.e. "a.b")
local SEP = ".";

# Valid number characters
local INT_CHARS = "0123456789";
local HEX_CHARS = "0123456789abcdefABCDEF";

# Compares two integers that have the same, non-zero sign, and are strings.
local cmpStr(a,b,negative) =
	if a == b then
		0
	else
		local aLen = std.length(a);
		local bLen = std.length(b);
		local a2 = if negative then std.substr(a, 1, aLen-1)  else a;
		local b2 = if negative then std.substr(b, 1, bLen-1) else b;
		local aLen2 = if negative then aLen-1  else aLen;
		local bLen2 = if negative then bLen-1 else bLen;
		local maxLen = std.max(aLen2, bLen2);
		local a3 = utl.extendStr(a2,maxLen,'0',true);
		local b3 = utl.extendStr(b2,maxLen,'0',true);
		local unsignedCmp = if a3 < b3 then -1 else 1;
		# Inverse result if negative is true!
		if negative then -unsignedCmp else unsignedCmp;

# Compares two integers that have the same, non-zero sign.
local cmpSameSign(a,b,negative) =
	local aType = std.type(a);
	local bType = std.type(b);
	if aType == bType then
		if aType == 'number' then
			if a == b then 0 else if a < b then -1 else 1
		else
			cmpStr(a,b,negative)
	else
		local aStr = if aType == 'string' then a else std.toString(a);
		local bStr = if bType == 'string' then b else std.toString(b);
		cmpStr(aStr,bStr,negative);

{
	local bigint = self,
	
	# Library description
	DESCIPTION:: "jsonnet library 'bigint' helps (a bit) dealing with integers, that are outside the range"
		+" that can correctly be represented\nas a 'number' (64bit double). For completness, it also "
		+"included a isNumberStr(), safeParseNumber(), isBooleanStr() und safeParseBoolean() functions.",
	
	# All the imported libraries
	IMPORTS:: { log: log, utl: utl },

	# Integer limit in JSON number
	MIN_SAFE_INTEGER:: -9007199254740991,
	MAX_SAFE_INTEGER:: 9007199254740991,

	# Returns true, if "str" is a boolean
	isBooleanStr(str)::
		(str == "true" || str == "false"),

	# Returns true, if "str" is an unsigned integer (even huge integers, that cannot be represented correctly
	# as a JSON number).
	isUIntegerStr(str)::
		(std.type(str) == "string") && (std.length(str) > 0) &&
			(std.length(std.stripChars(str, INT_CHARS)) == 0),

	# Returns true, if "str" is an integer (even huge integers, that cannot be represented correctly as a
	# JSON number).
	isIntegerStr(str)::
		if std.type(str) == "string" then
			if std.startsWith(str,'-') then
				bigint.isUIntegerStr(std.substr(str, 1, std.length(str)-1))
			else
				bigint.isUIntegerStr(str)
		else
			false,

	# Returns true, if "str" is a number
	isNumberStr(str)::
		if std.type(str) != "string" then
			false
		else
			local len = std.length(str);
			if len == 0 then
				false
			else
				local dots = std.findSubstr(SEP, str);
				local nDots = std.length(dots);
				if nDots == 0 then
					bigint.isIntegerStr(str)
				else if nDots == 1 then
					local lp = dots[0];
					local prefix = std.substr(str, 0, lp);
					# "+1" to skip separator too
					local rest = std.substr(str, lp+1, len-lp);
					bigint.isIntegerStr(prefix) && bigint.isUIntegerStr(rest)
				else
					false,

	# *Safely* parse a boolean value. Returns an object like { result: VALUE, errors: [] }
	# "result" is null and errors contains error message(s) if str is not a valid value.
	safeParseBoolean(source, index, field, str)::
		if bigint.isBooleanStr(str) then
			{ result: (str == "true"), errors: [] }
		else
			{ result: null, errors: [  log.badVal(source, index, field, 'boolean', str) ] },

	# Returns true, if "str" is an hexadecimal integer
	isHexStr(str)::
		if std.type(str) == "string" then
			local len = std.length(str);
			(len > 2) && (std.startsWith(str, "0x") || std.startsWith(str, "0X")) &&
				(std.length(std.stripChars(std.substr(str, 2, len-2), HEX_CHARS)) == 0)
		else
			false,

	# Returns true, if this integer is within the range that can be correctly represented as a JSON number
	isNotHugeInt(num)::
		(std.type(num) == "number") && bigint.isIntegerStr(std.toString(num)) &&
			(num >= bigint.MIN_SAFE_INTEGER) && (num <= bigint.MAX_SAFE_INTEGER),

	# *Safely* parse a integer value. Returns an object like { result: VALUE, errors: [] }
	# "result" is null and errors contains error message(s) if str is not a valid value.
	# "str" is potentially too "big" to be correctly represented with a "number".
	# In this case, it will remain a string, and a warning will be given in "errors".
	safeParseInteger(source, index, field, str)::
		if bigint.isIntegerStr(str) then
			# std.parseJson(str) will return a simple number value, if str is really a number
			local num = std.parseJson(str);
			if bigint.isNotHugeInt(num) then
				{ result: num, errors: [] }
			else
				{ result: str, errors: [ log.warnVal(source, index, field, 'integer', str,
					'cannot be safely represented as a number.') ] }
		else
			{ result: null, errors: [ log.badVal(source, index, field, 'integer', str) ] },

	# *Safely* parse a HEX integer value. Returns an object like { result: VALUE, errors: [] }
	# "result" is null and errors contains error message(s) if str is not a valid value.
	# "str" is potentially too "big" to be correctly represented with a "number".
	# In this case, it will remain a string, and a warning will be given in "errors".
	safeParseHex(source, index, field, str)::
		if bigint.isHexStr(str) then
			local num = std.parseHex(std.substr(str, 2, std.length(str)-2));
			# hex num will never be < 0!
			if num <= bigint.MAX_SAFE_INTEGER then
				{ result: num, errors: [] }
			else
				# TODO: ideally, we would still convert that hex string into a decimal str
				{ result: str, errors: [ log.warnVal(source, index, field, 'hex', str,
					'cannot be safely represented as a number.') ] }
		else
			{ result: null, errors: [ log.badVal(source, index, field, 'hex', str) ] },

	# *Safely* parse a decimal number value (i.e. '123.456'). Returns an object like { result: VALUE,
	# errors: [] }. "result" is null and errors contains error message(s) if str is not a valid value.
	safeParseNumber(source, index, field, str)::
		if bigint.isNumberStr(str) then
			# std.parseJson(str) will return a simple number value, if str is really a number
			{ result: std.parseJson(str), errors: [] }
		else
			{ result: null, errors: [ log.badVal(source, index, field, 'number', str) ] },
	
	# Returns -1, 0 or 1 based on the sign of the integer.
	sign(num)::
		# Assume num is an integer as string, if not a number ...
		std.sign(if std.type(num) == "number" then num else std.parseJson(num)),

	# Compares the integers a and b. Returns 0 if equals, 1 is a > b else -1
	cmp(a,b)::
		local aSign = bigint.sign(a);
		local bSign = bigint.sign(b);
		if aSign == 0 then
			if bSign == 0 then
				0
			else if bSign > 0 then
				-1
			else
				1
		else if aSign != bSign then
			if aSign > 0 then 1 else -1
		else
			# a and b have same sign, and are not 0, so we need "real" comparision
			cmpSameSign(a,b,aSign < 0),

	# Compares the integers a and b. Returns true if a < b.
	lt(a,b)::
		bigint.cmp(a,b) < 0,

	# Compares the integers a and b. Returns true if a <= b.
	le(a,b)::
		bigint.cmp(a,b) <= 0,

	# Compares the integers a and b. Returns true if a > b.
	gt(a,b)::
		bigint.cmp(a,b) > 0,

	# Compares the integers a and b. Returns true if a >= b.
	ge(a,b)::
		bigint.cmp(a,b) >= 0,

	# Compares the integers a and b. Returns true if a == b.
	eq(a,b)::
		bigint.cmp(a,b) == 0,

	# Compares the integers a and b. Returns true if a != b.
	ne(a,b)::
		bigint.cmp(a,b) != 0,

	# Compares the integers a and b. Returns the smallest one.
	min(a,b)::
		if bigint.cmp(a,b) < 0 then a else b,

	# Compares the integers a and b. Returns the biggest one.
	max(a,b)::
		if bigint.cmp(a,b) > 0 then a else b,

	# TODO: intAdd adds big integers, even if they are strings
	# TODO: intNeg negates big integers, even if they are strings
	# TODO: intSub substracts big integers, even if they are strings (use intNeg and intAdd for impl)
	
	# All functions in the library, with their parameter names
	FUNCS:: {
		isBooleanStr: ['str'],
		isUIntegerStr: ['str'],
		isIntegerStr: ['str'],
		isNumberStr: ['str'],
		safeParseBoolean: ['source', 'index', 'field', 'str'],
		isHexStr: ['str'],
		isNotHugeInt: ['num'],
		safeParseInteger: ['source', 'index', 'field', 'str'],
		safeParseHex: ['source', 'index', 'field', 'str'],
		safeParseNumber: ['source', 'index', 'field', 'str'],
		sign: ['num'],
		cmp: ['a','b'],
		lt: ['a','b'],
		le: ['a','b'],
		gt: ['a','b'],
		ge: ['a','b'],
		eq: ['a','b'],
		ne: ['a','b'],
		min: ['a','b'],
		max: ['a','b'],
	},
}